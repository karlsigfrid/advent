#while(is.na(t[row_col_finish[1], row_col_finish[2]])){
while(any(s == "E" & is.na(t))){
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle)
t <- update_t(new_locs, t, the_cycle)
the_cycle <- the_cycle + 1
}
print(the_cycle - 1)
t[row_col_finish[1], row_col_finish[2]]
good_neighbors <- function(this_row_col, s , t, down=FALSE){
let_v <- c(1, 1:26, 26)
names(let_v) <- c("S", letters, "E")
this_letter <- s[this_row_col[1], this_row_col[2]]
neighbors <-  this_row_col +
matrix(c(-1, 0, 1, 0, 0, -1, 0, 1), nrow=2)
neighbors <- data.frame(row=neighbors[1, ], col= neighbors[2, ])
neighbors <- neighbors[neighbors$row > 0 &
neighbors$row <= nrow(s) &
neighbors$col > 0 &
neighbors$col <= ncol(s), ]
neighbors$is_na <- apply(neighbors, 1, function(q) as.integer(is.na(t[q["row"], q["col"]])))
neighbors$letter <- apply(neighbors, 1, function(q) (s[q["row"], q["col"]]))
neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) <= 1, 1, 0)
})
if(down) neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) >= -1, 1, 0)
})
neighbors[neighbors$expand == 1, c("row", "col"), drop=F]
}
all_good_neighbors <- function(s, t, the_cycle){
last_loc <- which(t == the_cycle - 1, arr.ind = TRUE)
new_locs <- c()
for (i in 1:nrow(last_loc)){
new_loc <- good_neighbors(this_row_col = last_loc[i, ], s=s, t=t)
new_locs <- rbind(new_locs, new_loc)
}
new_locs <- unique(new_locs)
new_locs
}
update_t <- function(new_locs, t, the_cycle){
for(i in 1:nrow(new_locs)){
t[new_locs$row[i], new_locs$col[i]] <- the_cycle
}
t
}
#Initialize
s <- readLines("data/12b.txt") |>
strsplit(split="") |>
(function(.) do.call(rbind, .))()
## Part 1
row_col_start <- which(s == "S", arr.ind=TRUE)
row_col_finish <- which(s == "E", arr.ind=TRUE)
t <- matrix(NA, nrow=nrow(s), ncol=ncol(s))
t[row_col_start] <- 0
the_cycle <- 1
#while(is.na(t[row_col_finish[1], row_col_finish[2]])){
while(any(s == "E" & is.na(t))){
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle)
t <- update_t(new_locs, t, the_cycle)
the_cycle <- the_cycle + 1
}
print(the_cycle - 1)
#t[row_col_finish[1], row_col_finish[2]]
## Part 2
row_col_end <- which(s == "a", arr.ind=TRUE)
row_col_start <- which(s == "E", arr.ind=TRUE)
t <- matrix(NA, nrow=nrow(s), ncol=ncol(s))
t[row_col_start] <- 0
the_cycle <- 1
repeat{
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle, down=TRUE)
t <- update_t(new_locs, t, the_cycle)
if(any(s == "a" & !is.na(t))){
print(the_cycle)
break
}
the_cycle <- the_cycle + 1
}
good_neighbors <- function(this_row_col, s , t, down=FALSE){
let_v <- c(1, 1:26, 26)
names(let_v) <- c("S", letters, "E")
this_letter <- s[this_row_col[1], this_row_col[2]]
neighbors <-  this_row_col +
matrix(c(-1, 0, 1, 0, 0, -1, 0, 1), nrow=2)
neighbors <- data.frame(row=neighbors[1, ], col= neighbors[2, ])
neighbors <- neighbors[neighbors$row > 0 &
neighbors$row <= nrow(s) &
neighbors$col > 0 &
neighbors$col <= ncol(s), ]
neighbors$is_na <- apply(neighbors, 1, function(q) as.integer(is.na(t[q["row"], q["col"]])))
neighbors$letter <- apply(neighbors, 1, function(q) (s[q["row"], q["col"]]))
neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) <= 1, 1, 0)
})
if(down) neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) >= -1, 1, 0)
})
neighbors[neighbors$expand == 1, c("row", "col"), drop=F]
}
all_good_neighbors <- function(s, t, the_cycle, down=FALSE){
last_loc <- which(t == the_cycle - 1, arr.ind = TRUE)
new_locs <- c()
for (i in 1:nrow(last_loc)){
new_loc <- good_neighbors(this_row_col = last_loc[i, ], s=s, t=t, down=down)
new_locs <- rbind(new_locs, new_loc)
}
new_locs <- unique(new_locs)
new_locs
}
update_t <- function(new_locs, t, the_cycle){
for(i in 1:nrow(new_locs)){
t[new_locs$row[i], new_locs$col[i]] <- the_cycle
}
t
}
#Initialize
s <- readLines("data/12b.txt") |>
strsplit(split="") |>
(function(.) do.call(rbind, .))()
## Part 1
row_col_start <- which(s == "S", arr.ind=TRUE)
row_col_finish <- which(s == "E", arr.ind=TRUE)
t <- matrix(NA, nrow=nrow(s), ncol=ncol(s))
t[row_col_start] <- 0
the_cycle <- 1
#while(is.na(t[row_col_finish[1], row_col_finish[2]])){
while(any(s == "E" & is.na(t))){
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle)
t <- update_t(new_locs, t, the_cycle)
the_cycle <- the_cycle + 1
}
print(the_cycle - 1)
#t[row_col_finish[1], row_col_finish[2]]
## Part 2
row_col_end <- which(s == "a", arr.ind=TRUE)
row_col_start <- which(s == "E", arr.ind=TRUE)
t <- matrix(NA, nrow=nrow(s), ncol=ncol(s))
t[row_col_start] <- 0
the_cycle <- 1
repeat{
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle, down=TRUE)
t <- update_t(new_locs, t, the_cycle)
if(any(s == "a" & !is.na(t))){
print(the_cycle)
break
}
the_cycle <- the_cycle + 1
}
good_neighbors <- function(this_row_col, s , t, down=FALSE){
let_v <- c(1, 1:26, 26)
names(let_v) <- c("S", letters, "E")
this_letter <- s[this_row_col[1], this_row_col[2]]
neighbors <-  this_row_col +
matrix(c(-1, 0, 1, 0, 0, -1, 0, 1), nrow=2)
neighbors <- data.frame(row=neighbors[1, ], col= neighbors[2, ])
neighbors <- neighbors[neighbors$row > 0 &
neighbors$row <= nrow(s) &
neighbors$col > 0 &
neighbors$col <= ncol(s), ]
neighbors$is_na <- apply(neighbors, 1, function(q) as.integer(is.na(t[q["row"], q["col"]])))
neighbors$letter <- apply(neighbors, 1, function(q) (s[q["row"], q["col"]]))
neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) <= 1, 1, 0)
})
if(down){
neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) >= -1, 1, 0)
})
}
else{
neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) <= 1, 1, 0)
})
}
neighbors[neighbors$expand == 1, c("row", "col"), drop=F]
}
all_good_neighbors <- function(s, t, the_cycle, down=FALSE){
last_loc <- which(t == the_cycle - 1, arr.ind = TRUE)
new_locs <- c()
for (i in 1:nrow(last_loc)){
new_loc <- good_neighbors(this_row_col = last_loc[i, ], s=s, t=t, down=down)
new_locs <- rbind(new_locs, new_loc)
}
new_locs <- unique(new_locs)
new_locs
}
update_t <- function(new_locs, t, the_cycle){
for(i in 1:nrow(new_locs)){
t[new_locs$row[i], new_locs$col[i]] <- the_cycle
}
t
}
#Initialize
s <- readLines("data/12b.txt") |>
strsplit(split="") |>
(function(.) do.call(rbind, .))()
## Part 1
row_col_start <- which(s == "S", arr.ind=TRUE)
row_col_finish <- which(s == "E", arr.ind=TRUE)
t <- matrix(NA, nrow=nrow(s), ncol=ncol(s))
t[row_col_start] <- 0
the_cycle <- 1
#while(is.na(t[row_col_finish[1], row_col_finish[2]])){
while(any(s == "E" & is.na(t))){
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle)
t <- update_t(new_locs, t, the_cycle)
the_cycle <- the_cycle + 1
}
print(the_cycle - 1)
## Part 2
row_col_end <- which(s == "a", arr.ind=TRUE)
row_col_start <- which(s == "E", arr.ind=TRUE)
t <- matrix(NA, nrow=nrow(s), ncol=ncol(s))
t[row_col_start] <- 0
the_cycle <- 1
repeat{
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle, down=TRUE)
t <- update_t(new_locs, t, the_cycle)
if(any(s == "a" & !is.na(t))){
print(the_cycle)
break
}
the_cycle <- the_cycle + 1
}
good_neighbors <- function(this_row_col, s , t, down=FALSE){
let_v <- c(1, 1:26, 26)
names(let_v) <- c("S", letters, "E")
this_letter <- s[this_row_col[1], this_row_col[2]]
neighbors <-  this_row_col +
matrix(c(-1, 0, 1, 0, 0, -1, 0, 1), nrow=2)
neighbors <- data.frame(row=neighbors[1, ], col= neighbors[2, ])
neighbors <- neighbors[neighbors$row > 0 &
neighbors$row <= nrow(s) &
neighbors$col > 0 &
neighbors$col <= ncol(s), ]
neighbors$is_na <- apply(neighbors, 1, function(q) as.integer(is.na(t[q["row"], q["col"]])))
neighbors$letter <- apply(neighbors, 1, function(q) (s[q["row"], q["col"]]))
neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) <= 1, 1, 0)
})
if(down){
neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) >= -1, 1, 0)
})
}
else{
neighbors$expand <- apply(neighbors, 1, function(q){
ifelse(unlist(q["is_na"]) == 1 &
(let_v[unlist(q["letter"])] - let_v[this_letter]) <= 1, 1, 0)
})
}
neighbors[neighbors$expand == 1, c("row", "col"), drop=F]
}
all_good_neighbors <- function(s, t, the_cycle, down=FALSE){
last_loc <- which(t == the_cycle - 1, arr.ind = TRUE)
new_locs <- c()
for (i in 1:nrow(last_loc)){
new_loc <- good_neighbors(this_row_col = last_loc[i, ], s=s, t=t, down=down)
new_locs <- rbind(new_locs, new_loc)
}
new_locs <- unique(new_locs)
new_locs
}
update_t <- function(new_locs, t, the_cycle){
for(i in 1:nrow(new_locs)){
t[new_locs$row[i], new_locs$col[i]] <- the_cycle
}
t
}
#Initialize
s <- readLines("data/12b.txt") |>
strsplit(split="") |>
(function(.) do.call(rbind, .))()
## Part 1
row_col_start <- which(s == "S", arr.ind=TRUE)
row_col_finish <- which(s == "E", arr.ind=TRUE)
t <- matrix(NA, nrow=nrow(s), ncol=ncol(s))
t[row_col_start] <- 0
the_cycle <- 1
#while(is.na(t[row_col_finish[1], row_col_finish[2]])){
while(any(s == "E" & is.na(t))){
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle)
t <- update_t(new_locs, t, the_cycle)
the_cycle <- the_cycle + 1
}
print(the_cycle - 1)
## Part 2
row_col_end <- which(s == "a", arr.ind=TRUE)
row_col_start <- which(s == "E", arr.ind=TRUE)
t <- matrix(NA, nrow=nrow(s), ncol=ncol(s))
t[row_col_start] <- 0
the_cycle <- 1
repeat{
new_locs <- all_good_neighbors(s=s, t=t, the_cycle=the_cycle, down=TRUE)
t <- update_t(new_locs, t, the_cycle)
if(any(s == "a" & !is.na(t))) break
the_cycle <- the_cycle + 1
}
the_cycle
knitr::opts_chunk$set(echo = TRUE)
N <- 9
n <- 3
y <- c(12, 19, 34, 28, 61, 78, 76, 61, 77)
t_yU <- sum(y)
t_yU
combos <- combn(x=1:9, m=3)
s <- apply(combos, 2, function(q) paste0("{", paste(q, collapse=""), "}"))
df <- data.frame(s=s, ps= 1 / choose(9, 3))
df$ty_hat <- apply(combos, 2, function(q) sum(y[q]) * N / n)
df
#Only applies to SIR, but can handle larger N
calc_hat_V1 <- function(sample_number, combos, N, y){
n <- nrow(combos)
pi_k <- n / N
pi_kl <- n * (n - 1) / (N * (N - 1))
delta_kk <- n / N * (1 - n / N)
delta_kl <- -n / N * (1 - n / N) / (N - 1)
common_div <- pi_kl * pi_k^2
kl_grid <- expand.grid(k=combos[, sample_number], l=combos[, sample_number])
kl_grid$delta_kl <- ifelse(kl_grid$k == kl_grid$l, delta_kk, delta_kl)
kl_grid$yk <- y[kl_grid$k]
kl_grid$yl <- y[kl_grid$l]
kl_grid$pi_kl <- ifelse(kl_grid$k == kl_grid$l, pi_k, pi_kl)
kl_grid$pi_k_pi_l <- pi_k^2
kl_grid$prod <- kl_grid$delta_kl * kl_grid$yk * kl_grid$yl /
(kl_grid$pi_kl * kl_grid$pi_k_pi_l)
sum(kl_grid$prod)
}
#Applies to any sampling design where pi_kl > 0 for all k, l
calc_hat_V1b <- function(sample_number, Ik, N, y){
s <- which(Ik[sample_number, ] == 1)
n <- length(s)
pi_all <- colSums(Ik) / nrow(Ik)
kl_grid <- expand.grid(k=s, l=s)
kl_grid$pi_k <- pi_all[kl_grid$k]
kl_grid$pi_l <- pi_all[kl_grid$l]
kl_grid$pi_kl <-
apply(kl_grid, 1, function(q) sum(Ik[, unlist(q["k"])] * Ik[, unlist(q["l"])]) / nrow(Ik))
kl_grid$delta_kl <- ifelse(kl_grid$k == kl_grid$l,
kl_grid$pi_k * (1 - kl_grid$pi_k),
kl_grid$pi_kl - kl_grid$pi_k * kl_grid$pi_l)
kl_grid$yk <- y[kl_grid$k]
kl_grid$yl <- y[kl_grid$l]
kl_grid$prod <- kl_grid$delta_kl * kl_grid$yk * kl_grid$yl /
(kl_grid$pi_kl * kl_grid$pi_k * kl_grid$pi_l)
sum(kl_grid$prod)
}
df$V1 <- sapply(1:nrow(df), calc_hat_V1, combos=combos, N=9, y=y)
Ik <- sapply(1:N, function(x) apply(combos, 2, function(q) as.integer(x %in% q)))
#Second version, should give the same result
df$V1b <- sapply(1:nrow(df), calc_hat_V1b, Ik=Ik, N=9, y=y)
df
df$V_hat_Res54 <- apply(combos, 2, function(q){
S2s <- (1 / (n - 1)) * sum((y[q] - mean(y[q]))^2)
(N^2 / n) * (1 - n / N) * S2s
})
df
E_V_hat_ty_hat <- sum(df$ps * df$ty_hat)
E_V_hat_ty_hat
V_Def20 <- sum(df$ps * (df$ty_hat - mean(df$ty_hat))^2)
V_Def20
kl_grid <- expand.grid(k=1:N, l=1:N)
kl_grid$delta_kl <- ifelse(kl_grid$k == kl_grid$l,
n / N * (1 - n / N),
- n / N * (1 - n / N) * (1 / (N - 1)))
kl_grid$y_k <- y[kl_grid$k]
kl_grid$y_l <- y[kl_grid$l]
kl_grid$pi_k <- kl_grid$pi_l <- n / N
kl_grid$prod <- kl_grid$delta_kl * kl_grid$y_k * kl_grid$y_l / (kl_grid$pi_k * kl_grid$pi_l)
sum(kl_grid$prod)
SyU2 <- (1 / (N - 1)) * sum((y - mean(y))^2)
N^2 / n * (1 - n / N) * SyU2
E_V1 <- sum(df$ps * df$V1)
E_V1
sir <- function(N, n){
nu <- runif(n=N, min=0, max=1)
order(nu)[1:n]
}
#Example
sir(N=100, n=10)
ex14 <- read.csv("Exercise14.csv")
# Calculate the true value t_{y,U}
t_y <- sum(ex14$y)
# Draw samples
N <- nrow(ex14)
n <- 15
R <- 1000
alpha <- 0.05
df_samples <- c()
for (i in 1:R){
sample_indices <- sir(N = N, n=n)
y_sample <- ex14$y[sample_indices]
t_hat <- (N / n) * sum(y_sample)
Sys2 <- (1 / (n - 1)) * sum((y_sample - mean(y_sample))^2)
V_hat <- (N^2 / n) * (1 - n / N) * Sys2
CI_l <- t_hat + qnorm(p = alpha/2, lower.tail = T) * sqrt(V_hat)
CI_u <- t_hat + qnorm(p = alpha/2, lower.tail = F) * sqrt(V_hat)
I_cov <- ifelse(t_y >= CI_l & t_y <= CI_u, 1, 0)
df_samples <- rbind(df_samples,
data.frame(t_hat = t_hat, V_hat = V_hat,
CI_l = CI_l, CI_u = CI_u, I_cov = I_cov))
}
head(df_samples)
# Approximations from the samples
ty_approx <- (1 / R) * sum(df_samples$t_hat)
V_ty_approx1 <- (1 / R) * sum(df_samples$V_hat)
V_ty_approx2 <- (1 / (R - 1)) * sum((df_samples$t_hat - mean(df_samples$t_hat))^2)
CI_1_minus_alpha_approx <- (1 / R) * sum(df_samples$I_cov)
#True values calculated from populatiob
SyU2 <- (1 / (N - 1)) * sum((ex14$y - mean(ex14$y))^2)
V_ty <- (N^2 / n) * (1 - n / N) * SyU2
# The total of y
t_y
ty_approx
# The variance of the total of y
V_ty_approx1
V_ty_approx2
V_ty
# The percentage of samples that cover the true total of y
CI_1_minus_alpha_approx
hist(df_samples$t_hat, breaks=20,
main=paste0("Histogram of the sample totals (n=", R, ")"),
xlab="Estimated total of y")
t_yU <- sum(y)
t_yU
combos <- combn(1:9, 3)
combos_s <- apply(combos, 2, paste, collapse=",")
combos_s2 <- paste0("{", combos_s, "}")
combos_s3 <- paste0(combos_s2, "\n")
for (s in combos_s3) cat(s)
# define the function to integrate
# x is a scalar, lambda is a vector of size n for the sample
# lambdas is a vector of all N lambdas in U
f <- function(x, lambda, lambdas){
n <- length(lambda)
tau_s <- lambda / (1 - lambda)
tau_U <- lambdas / (1 - lambdas)
x^(n-1) * sum(1 / (1 + tau_s * x)) / prod(1 + tau_U  * x)
}
# Vectorized version of f, needed for the numeric integration
f2 <- function(x, lambda, lambdas) sapply(x, f, lambda=lambda, lambdas=lambdas)
lambdas <- c(0.80,0.55,0.40,0.30,0.25,0.25,0.20,0.15,0.10)
tau_k <- lambdas / (1- lambdas)
n <- ncol(combos)
s_integrals <- apply(combos, 2, function(q) integrate(f=f2, lower=0, upper=Inf,
lambda= lambdas[q], lambdas=lambdas)$value)
ps <- sapply(1:n, function(q) prod(tau_k[combos[, q]]) * s_integrals[q])
# Print the calculated sample probabilities
df <- data.frame(s=combos_s2, ps=ps)
df
sum(df$ps)
combos <- combn(1:9, 3)
combos_s <- apply(combos, 2, paste, collapse=",")
combos_s2 <- paste0("{", combos_s, "}")
combos_s3 <- paste0(combos_s2, "\n")
for (s in combos_s3) cat(s)
# define the function to integrate
# x is a scalar, lambda is a vector of size n for the sample
# lambdas is a vector of all N lambdas in U
f <- function(x, lambda, lambdas){
n <- length(lambda)
tau_s <- lambda / (1 - lambda)
tau_U <- lambdas / (1 - lambdas)
x^(n-1) * sum(1 / (1 + tau_s * x)) / prod(1 + tau_U  * x)
}
# Vectorized version of f, needed for the numeric integration
f2 <- function(x, lambda, lambdas) sapply(x, f, lambda=lambda, lambdas=lambdas)
lambdas <- c(0.80,0.55,0.40,0.30,0.25,0.25,0.20,0.15,0.10)
tau_k <- lambdas / (1- lambdas)
n <- ncol(combos)
s_integrals <- apply(combos, 2, function(q) integrate(f=f2, lower=0, upper=Inf,
lambda= lambdas[q], lambdas=lambdas)$value)
ps <- sapply(1:n, function(q) prod(tau_k[combos[, q]]) * s_integrals[q])
# Print the calculated sample probabilities
df <- data.frame(s=combos_s2, ps=ps)
head(df)
sum(df$ps)
combos <- combn(1:9, 3)
combos_s <- apply(combos, 2, paste, collapse=",")
combos_s2 <- paste0("{", combos_s, "}")
combos_s3 <- paste0(combos_s2, "\n")
#for (s in combos_s3) cat(s)
# define the function to integrate
# x is a scalar, lambda is a vector of size n for the sample
# lambdas is a vector of all N lambdas in U
f <- function(x, lambda, lambdas){
n <- length(lambda)
tau_s <- lambda / (1 - lambda)
tau_U <- lambdas / (1 - lambdas)
x^(n-1) * sum(1 / (1 + tau_s * x)) / prod(1 + tau_U  * x)
}
# Vectorized version of f, needed for the numeric integration
f2 <- function(x, lambda, lambdas) sapply(x, f, lambda=lambda, lambdas=lambdas)
lambdas <- c(0.80,0.55,0.40,0.30,0.25,0.25,0.20,0.15,0.10)
tau_k <- lambdas / (1- lambdas)
n <- ncol(combos)
s_integrals <- apply(combos, 2, function(q) integrate(f=f2, lower=0, upper=Inf,
lambda= lambdas[q], lambdas=lambdas)$value)
ps <- sapply(1:n, function(q) prod(tau_k[combos[, q]]) * s_integrals[q])
# Print the calculated sample probabilities
df <- data.frame(s=combos_s2, ps=ps)
head(df)
sum(df$ps)
